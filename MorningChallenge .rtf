{\rtf1\ansi\ansicpg1252\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red246\green246\blue239;\red117\green113\blue92;\red29\green30\blue26;
}
{\*\expandedcolortbl;;\cssrgb\c97255\c97255\c94902;\cssrgb\c53333\c51765\c43529;\cssrgb\c15294\c15686\c13333;
}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
\pard\pardeftab720\partightenfactor0
\cf3 \cb4 \strokec3 // // ================== getAverages =====================\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // Question:\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // // Write a function that takes in an array of integers and returns an object with keys minimum, maximum, average with correct values.\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // ====================================================\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // Solution(s):\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // const getAverages = (arr) => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     let object = \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         max: arr[0],\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         min: arr[0],\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         avg: 0\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     arr.forEach(item => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         if (item > object.max) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //             object.max = item\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         if (item < object.min) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //             object.min = item\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         object.avg += item\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \})\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     object.avg = object.avg / arr.length\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     return object\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \}\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // // console.log(arr)\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // // console.log(getAverages(arr))\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // using reduce\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // // important with this is using the initialValue for the accumulator (which would be the object that needs to be returned)\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // const reduceAverages = (arr) => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   let object = arr.reduce((obj, item) => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     if (item > obj.max) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       obj.max = item\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     if (item < obj.min) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       obj.min = item\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     obj.avg += item;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     return obj;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   \}, \{max: arr[0], min: arr[0], avg: 0\})\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   object.avg = object.avg / arr.length\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   return object;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // let newArr = [1, 6, 4, 8, 2, 9, 0, 12]\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // console.log(newArr)\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // console.log(reduceAverages(newArr))\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // ================== countArray =====================\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // Question:\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // // Given an array of integers, return an array where the first element is the count of positives numbers and the second element is sum of negative numbers.\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // ===================================================\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // Solution(s):\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // function countArray(array) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     let result = [0, 0];\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 //     for (let i = 0; i < array.length; i++) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         if (array[i] > 0) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //             result[0] = result[0] + 1;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         \} else \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //             result[1] = result[1] + array[i]\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \}\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 //     return result;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \}\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // using forEach\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // function countArray(array) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     let result = [0, 0];\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     array.forEach(item => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       item > 0 ? result[0]++ : result[1]+= item\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \})\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     return result;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \}\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // //using reduce\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // function countArray(array) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     return array.reduce((result, item) => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         item > 0 ? result[0]++ : result[1]+= item;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         return result;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \}, [0,0])\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \}\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // console.log(countArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15]))\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // Morning Challenge\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // Merge Arrays - Solution 1\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // function mergeArray (a,b) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     let arr = []\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     let longer = a.length > b.length ? a : b\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     let shorter = a.length < b.length ? b : a\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     for (let i = 0; i < longer.length; i++) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         if ( a[i] !== undefined) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //             arr.push(a[i])\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         \} if (b[i] !== undefined) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //             arr.push(b[i])\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     return arr\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \}\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // console.log(mergeArray(['a', 'b', 'c', 'd'], [1, 2, 3, 4]));\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // Merge Arrays - Solution 2\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // var array1 = [a, b, c, d],\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     array2 = [1, 2, 3, 4]\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     result = [array1, array2]\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         .reduce((r, a) => (a.forEach((a, i) => (r[i] = r[i] || []).push(a)), r), [])\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //         .reduce((a, b) => a.concat(b));\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // console.log(result);\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // const obj1 = \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   name: "Omer",\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   hobbies: ["martial arts", "yoga", "complaining?"],\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   height: 183,\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \};\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // let \{ name, height \} = obj1;\cf2 \cb1 \strokec2 \
\
\
\
\cf3 \cb4 \strokec3 // ================== halloween ======================\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // Question:\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // It's Halloween! Kids are trick-or-treating and you're noticing that even within a group, certain kids always have more candy than others.\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // Given an array of integers, representing how many candies each kid has, find out which kid has the most candies.\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // After giving each kid the same amount of candies, which kids will have more than the kid with the most before you added to their loot.\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // Return an array of booleans.\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // ===================================================\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // Solution(s):\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //using map\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // const halloween = (kidsWithCandies, extraCandies) => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   let maxCandies = kidsWithCandies[0]\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   kidsWithCandies.forEach(kidCandies => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       if (kidCandies > maxCandies) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //           maxCandies = kidCandies\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   \})\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   return kidsWithCandies.map((candy) => candy + extraCandies >= maxCandies);\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \};\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // //using map and reduce\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // const halloweenMR = (kidsWithCandies, extraCandies) => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   let maxCandies = kidsWithCandies.reduce((i, a) => (i > a ? i : a));\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   console.log(maxCandies)\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   return kidsWithCandies.map((candy) => candy + extraCandies >= maxCandies);\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \};\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // console.log(halloween([2, 3, 5, 1, 3], 3))\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // console.log(halloweenMR([2, 3, 5, 1, 3], 3))\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // Soln 3 from class\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // const halloween = (candies, extraAmount) => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   const max = Math.max(...candies);\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   const moreCandiesThanMax = [];\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   for (let i = 0; i < candies.length; i++) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     candies[i] = candies[i] + extraAmount;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     if (candies[i] >= max) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       moreCandiesThanMax.push(true);\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \} else \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       moreCandiesThanMax.push(false);\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //     \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   return moreCandiesThanMax;\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \};\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // console.log(halloween([2, 3, 5, 1, 3], 3));\cf2 \cb1 \strokec2 \
\
\
\cf3 \cb4 \strokec3 // ================== doubleUp ======================\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // Question: \cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // Given a string, you have to return a string in which each character (case-sensitive) is repeated once. \cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // "Hello World" => "HHeelloo  WWoorrlldd"\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // ==================================================\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // Solution 1\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // function doubleUp(str) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   let arr = str.split('');\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   for (let i = 0; i < str.length; i++) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       arr.splice((i * 2 + 1), 0, arr[i * 2]) \cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   \}\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   return arr.join('')\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \}\cf2 \cb1 \strokec2 \
\
\cf3 \cb4 \strokec3 // // soln 2 using map\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // function doubleUpM(str) \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   let arr = str.split('')\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   let final = arr.map(item => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       return `$\{item\}$\{item\}`\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   \})\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   return final.join('')\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \}\cf2 \cb1 \strokec2 \
\
\
\cf3 \cb4 \strokec3 // //solution 3 from class\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // const doubleUp = (str) => \{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   const letterArray = str.split('');\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   const doubledArray = letterArray.map((letter)=>\{\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //       return letter.repeat(2);\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   \})\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 //   return doubledArray.join('')\cf2 \cb1 \strokec2 \
\cf3 \cb4 \strokec3 // \};\cf2 \cb1 \strokec2 \
}